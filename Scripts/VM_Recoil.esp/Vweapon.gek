scn Vweapon

ref rVM_Weapon

ref vSelf

float pSkill
float pStr
float wDam
float wSkillType
float wSkill
float wStr

float VMx
float VMy
float VMz

array_var DefTrans2
array_var DefTrans1
float DefX
float DefY
float DefZ

float vVInt
float vHInt
float vWDamCoeff
float vWDamCoeffH
float vSCoeffV
float vSCoeffH
float vWInfV
float vWInfH
float vIsRand

float randn
float randWY
float randWZ
float Ystack

float HasInertia
float IsVats

float fixMult
float fixMultIS

float vVlowLim
float vVupLim
float vHlowLim
float vHupLim

float vConst
float vStrBased
float vSkillBased
float vWeight

float vISconst
float vISstrBonus
float vISskillBonus
float vISlimitMult

ref CurAm
array_var KnownAmmoName
array_var KnownAmmoD
string_var CurAmName
string_var CurAmNameMetrB
string_var CurAmNameMetrA
int CurAmNameMetrBS
int CurAmNameMetrAS
array_var CurAmNameSym
float CurAmNameDig
int CurAmNameMetr
float CurAmDiameter
float CurAmDiameterCorr
string_var CurAmDiameterCorrINI
string_var CurAmDiameterCorrINIFULL
int isDebug

ref CurAmEff 
ref CurWepProj 
int ii
float CurAmEffVal
float CurAmEffType
float projSpeed
float projDam

float vUseAmmoPseudo
float vUseIndRec
string_var WeaponSname
string_var WeaponSnameHAS
float WeaponSnameHASX
float WSR_aggMastery
float vcIS
float vFirstShotMV
float vFirstShotMH
float vFirstShotR
float vFirstShotP
float vFirstShotV
float vFirstShotH

float vRotationAsVertical

float timer

begin Function {rVM_Weapon}

	if IsPC1stPerson == 1 || IsModLoaded "CameraRecoil.esp" ; let's try to make TPS recoil work properly
		; I have no idea how reading from ini files affects performance
		;so I've added this feature for convenience and POSSIBLE optimization
		if (GetINIFloat "Optimization:vDirectLoad" "VM_Recoil.ini") == 1
		
			set vVInt to GetINIFloat "General:vVerticalIntensity" "VM_Recoil.ini"
			set vHInt to GetINIFloat "General:vHorizontalIntensity" "VM_Recoil.ini"
			set vWDamCoeff to GetINIFloat "General:vWeaponDamageCoeff" "VM_Recoil.ini"
			set vWDamCoeffH to GetINIFloat "General:vWeaponDamageCoeffH" "VM_Recoil.ini"
			set vSCoeffV to GetINIFloat "Stats:vStrengthCoeffV" "VM_Recoil.ini"
			set vSCoeffH to GetINIFloat "Stats:vStrengthCoeffH" "VM_Recoil.ini"
			set vWInfV to GetINIFloat "Stats:vWeightInfluenceV" "VM_Recoil.ini"
			set vWInfH to GetINIFloat "Stats:vWeightInfluenceH" "VM_Recoil.ini"
			set vIsRand to GetINIFloat "Randomization:vIsRandomized" "VM_Recoil.ini"
			
			set vVlowLim to GetINIFloat "General:vVerticalLowerLimit" "VM_Recoil.ini"
			set vVupLim to GetINIFloat "General:vVerticalUpperLimit" "VM_Recoil.ini"
			set vHlowLim to GetINIFloat "General:vHorizontalLowerLimit" "VM_Recoil.ini"
			set vHupLim to GetINIFloat "General:vHorizontalUpperLimit" "VM_Recoil.ini"
			set IsVats to GetINIFloat "BUGFIXING:vVATSfix" "VM_Recoil.ini"
			set vUseIndRec to GetINIFloat "Individual:vUseIndividualRecoil" "VM_Recoil.ini"
			set vUseAmmoPseudo to GetINIFloat "Stats:vUseAmmoPseudoCalc" "VM_Recoil.ini"
			set vFirstShotMV to GetINIFloat "Randomization:vFirstShotMultiplierV" "VM_Recoil.ini"
			set vFirstShotMH to GetINIFloat "Randomization:vFirstShotMultiplierH" "VM_Recoil.ini"
			set vFirstShotP to GetINIFloat "Randomization:vFirstShotPeriod" "VM_Recoil.ini"
			set vFirstShotR to GetINIFloat "Randomization:vFirstShotRandomization" "VM_Recoil.ini"
			set vRotationAsVertical to GetINIFloat "Randomization:vRotationAsVertical" "VM_Recoil.ini"
			
		else
		
			set vVInt to VisuaModellRecoilQuest.vVerticalIntensity
			set vHInt to VisuaModellRecoilQuest.vHorizontalIntensity
			set vWDamCoeff to VisuaModellRecoilQuest.vWeaponDamageCoeff
			set vWDamCoeffH to VisuaModellRecoilQuest.vWeaponDamageCoeffH
			set vSCoeffV to VisuaModellRecoilQuest.vStrengthCoeffV
			set vSCoeffH to VisuaModellRecoilQuest.vStrengthCoeffH
			set vWInfV to VisuaModellRecoilQuest.vWeightInfluenceV
			set vWInfH to VisuaModellRecoilQuest.vWeightInfluenceH
			set vIsRand to VisuaModellRecoilQuest.vIsRandomized
			set vRotationAsVertical to VisuaModellRecoilQuest.vRotationAsVertical
			
			set vVlowLim to VisuaModellRecoilQuest.vVlowLim
			set vVupLim to VisuaModellRecoilQuest.vVupLim
			set vHlowLim to VisuaModellRecoilQuest.vHlowLim
			set vHupLim to VisuaModellRecoilQuest.vHupLim
			set IsVats to VisuaModellRecoilQuest.IsVats
			set vUseIndRec to VisuaModellRecoilQuest.vUseIndRec
			set vUseAmmoPseudo to VisuaModellRecoilQuest.vUseAmmoPseudo
			set vFirstShotMV to VisuaModellRecoilQuest.vFirstShotMV
			set vFirstShotMH to VisuaModellRecoilQuest.vFirstShotMH
			set vFirstShotP to VisuaModellRecoilQuest.vFirstShotP
			set vFirstShotR to VisuaModellRecoilQuest.vFirstShotR
			
		endif
		
		; PrintToConsole "vVInt is: %g" vVInt
		; PrintToConsole "vHInt is: %g" vHInt
		; PrintToConsole "vSCoeffV is: %g" vSCoeffV
		; PrintToConsole "vSCoeffH is: %g" vSCoeffH
		; PrintToConsole "vWInfV is: %g" vWInfV
		; PrintToConsole "vWInfH is: %g" vWInfH
		; PrintToConsole "vIsRand is: %g" vIsRand
		
		let timer := GetSecondsPassed
		
		let wSkillType := GetWeaponSkill rVM_Weapon
		
		if wSkillType !=34 && wSkillType !=41 && wSkillType != 33 && wSkillType != 35
			let DefY := 0
			let DefX := 0
			let DefZ := 0
		
			let timer -= GetSecondsPassed
			if isDebug 
				Print "Your weapon probably shouldn't have any recoil. In " + $timer + "s"
			endif
		else
			let pStr := player.getav strength
			if pStr < 1
				let pStr := 1
			elseif pStr > 11
				let pStr := 11
			endif
			
			let wSkill := GetWeaponRequiredSkill rVM_Weapon
			let wStr := GetWeaponRequiredStrength rVM_Weapon
			
			;PrintToConsole "wStr is: %g" wStr
			
			if wSkill < 5
				let wSkill := 5
			endif
			if wStr < 1
				let wStr := 1
			endif
			
			if wSkillType == 34
				let pSkill := player.getav energyweapons
			elseif wSkillType == 41
				let pSkill := player.getav guns
			elseif wSkillType == 33
				let pSkill := player.getav bigguns
			elseif wSkillType == 35
				let pSkill := player.getav explosives	
			endif
			
			if pSkill < 1
				let pSkill := 1
			elseif pSkill > 110
				let pSkill := 110
			endif
			
			;PrintToConsole "pSkill is: %g" pSkill
			
			let wDam := GetDamage rVM_Weapon
			;PrintToConsole "wDam is: %g" wDam
			let HasInertia := IsModLoaded "B42Inertia.esp"
			;PrintToConsole "B42Inertia is: %g" HasInertia
			;don't mind the var name, tried to replace damage with projectile params
			
			let vConst := 2 - GetWeaponIsAutomatic rVM_Weapon
			
		; AMMO EFFECTS
			set CurAm to GetPlayerCurrentAmmo	
			let CurAmEffVal := 1
			;Print "CurAmEffVal is: " + $CurAmEffVal
			
			if eval Ar_HasKey VisuaModellRecoilQuest.FixedAmmos $CurAm
			let CurAmEffVal:= VisuaModellRecoilQuest.FixedAmmos[$CurAm]
			;Print "We have " + $CurAmEffVal + " at home"
			else
				; until GetNthAmmoEffect is fixed I have to add an empty effect, calc, write to array and delete effect
				; NEVERMIND indexes start form 0. This is what you get when you start programming from Lua
				;AddAmmoEffect CurAm dirdtydirtyAEfix
				
				set ii to GetNumAmmoEffects CurAm
				;print "ii="+$ii + " in " + $CurAm
			
				if ii > 0
					let CurAmEffType := 1
					while ii > 0
						let ii -= 1
						;print "ii="+$ii
						set CurAmEff to GetNthAmmoEffect CurAm ii
						let CurAmEffType := GetAmmoEffectTraitNumeric CurAmEff 0
						;Print "CurAmEff!: " + $CurAmEff + ", "+$CurAmEffType
						if CurAmEffType == 0
							let CurAmEffVal := GetAmmoEffectTraitNumeric CurAmEff 2
							
							;PrintToConsole "WARNING!: %g" CurAmEffVal
							; just in case
							if CurAmEffVal <= 0 
								let CurAmEffVal := 1
							endif
						endif
						
					loop
				endif
				
				let VisuaModellRecoilQuest.FixedAmmos[$CurAm] := CurAmEffVal	
				;RemoveAmmoEffect CurAm dirdtydirtyAEfix
			endif
			;PrintToConsole "CurAmEffVal is: %g" CurAmEffVal
			let wDam *= CurAmEffVal
			
		; AMMO EFFECTS END
		
		; CALIBERS
			
			if vUseAmmoPseudo == 1	
				set isDebug to GetINIFloat "BUGFIXING:vDebugAmmo" "VM_Recoil.ini"
				
				if isDebug 
					Print "Damage before " + $wDam 
				endif
				
				let wDam := Call vGetAmmoCalc wDam
				
				if isDebug 
					Print "Damage after " + $wDam
				endif
			endif	
		
		;CALIBERS END
		
		
			let vConst := 2 - GetWeaponIsAutomatic rVM_Weapon
			
			;PrintToConsole "GetNumAmmoEffects is: %g" ii
			; time to fiddle with explosive weapons
			if wSkillType == 35
				set CurWepProj to GetWeaponProjectile rVM_Weapon
				;let projDam := GetProjectileRefDamage
				
				let projSpeed := GetProjectileTraitNumeric CurWepProj 2
				let projDam := GetProjectileTraitNumeric CurWepProj 9
				
				;PrintToConsole "projDam is: %g" projDam
				;PrintToConsole "projSpeed is: %g" projSpeed
				
				let wDam *= projDam*projSpeed
			endif
			

			;PrintToConsole "wDam result is: %g" wDam
			
			if GetPCUsingIronSights
				let vISconst := GetINIFloat "Ironsights:vConstantCoefficient" "VM_Recoil.ini"
				;let vISstrBonus := GetINIFloat "Ironsights:vIronsightsStrengthBonus" "VM_Recoil.ini"
				let vISskillBonus := GetINIFloat "Ironsights:vIronsightsSkillBonus" "VM_Recoil.ini"
				let vISlimitMult := GetINIFloat "Ironsights:vIronsightsLimitsMultiplier" "VM_Recoil.ini"
				let vConst *= vISconst
				;let pStr += vISstrBonus - doesn't work for "front-heavy weapons" part formula, oops 
				let pSkill += vISskillBonus
				; and for the limits too
				let vVupLim *= vISlimitMult
				let vVlowLim *= vISlimitMult
				let vHupLim *= vISlimitMult
				let vHlowLim *= vISlimitMult
				
			endif
			let vStrBased := wStr/pStr ; min 0,091 max 10, -
			let vSkillBased := pSkill/wSkill ; min 0,05 max 22, +
			let vWeight := (GetWeight rVM_Weapon)/pStr
			
			; PrintToConsole "vConst is: %g" vConst
			;PrintToConsole "vStrBased is: %g" vStrBased
			;PrintToConsole "vSkillBased is: %g" vSkillBased
			; PrintToConsole "vWeight is: %g" vWeight
			
			;           constant part   strength-based part    damage and skill-based part     	weight-based part (heavy weapons climb less afaik - let's just assume they all are front-heavy)
			
			let WSR_aggMastery := 1/vSkillBased + vStrBased; - ( abs DefY + abs DefX + abs DefZ)
			;PrintToConsole "WSR_aggMastery is: %g" WSR_aggMastery
			
			set WeaponSname to GetEditorID rVM_Weapon
			let WeaponSname :="WeaponVRecoil\" + WeaponSname + ".ini"
			let WeaponSnameHAS :="Config\" + WeaponSname
			let WeaponSnameHASX := FileExists $WeaponSnameHAS
			
			if isDebug
				Print "Individual ini is: " + $WeaponSnameHAS + " " + $WeaponSnameHASX
			endif
			
			if vUseIndRec && WeaponSnameHASX
				
				
				let DefY := GetINIFloat "PATTERN:Y" $WeaponSname
				let DefX := GetINIFloat "PATTERN:X" $WeaponSname
				let DefZ := GetINIFloat "PATTERN:Z" $WeaponSname
				
				
								
				
				if GetPCUsingIronSights
					let vcIS := GetINIFloat "PATTERN:cIS" $WeaponSname
					let DefY *= WSR_aggMastery*vcIS
					let DefX *= WSR_aggMastery*vcIS
					let DefZ *= WSR_aggMastery*vcIS
				else 
					let DefY *= WSR_aggMastery
					let DefX *= WSR_aggMastery
					let DefZ *= WSR_aggMastery
				endif
				
				
				
				let randn := GetINIFloat "PATTERN:dX" $WeaponSname
				if randn < 0 ; randomization left and right
					if getrandompercent > 50
						let randn *= -1
					endif
				else ; rand, but still to one side
					if getrandompercent > 50
						let randn := 1
					endif
				endif
				
				let randWY := GetINIFloat "PATTERN:dY" $WeaponSname
				if randWY < 0 ; pseudo constant recoil
					if getrandompercent/100 < -1*randWY
						let DefY := 0
					endif
				else  ; rand for one side, but a little
					if getrandompercent < 50
						let DefY := DefY + randWY
					endif
				endif
				
				let randWZ := GetINIFloat "PATTERN:dZ" $WeaponSname
				
				if randWZ < 0 ; rand
					if getrandompercent > 50
						let randWZ *= -1
						let DefZ *= randWZ
					endif
				else ; like Y
					if getrandompercent < 50
						let DefZ := DefZ + randWZ
					endif
				endif
				

				if isDebug
					;PrintToConsole "DefX IR is: %g" DefX
					;PrintToConsole "DefY IR is: %g" DefY
					;PrintToConsole "DefZ IR is: %g" DefZ
				endif
				
				if isDebug
					;PrintToConsole "DefY +randWY is: %g" DefY
					;PrintToConsole "randWZ is: %g" randWZ
					Print "vWeight=" + $vWeight
				endif


				;PrintToConsole "DefY +randWY is: %g" DefY
				;PrintToConsole "randWZ is: %g" randWZ
				
			else
				if (GetINIFloat "Individual:vUseOldGenericFormula" "VM_Recoil.ini") == 1
					let DefY := vVInt*vConst + (vStrBased*vSCoeffV) + (vWDamCoeff*wDam - vSkillBased) - vWeight*vWInfV
					let DefX := vHInt*vConst + (vStrBased*vSCoeffH) + (vWDamCoeff*wDam - vSkillBased)*vWDamCoeffH + vWeight*vWInfH
				else
					let DefY := (vVInt*vConst + vWDamCoeff*wDam - vWInfV/vWeight)*WSR_aggMastery*vSCoeffV
					let DefX := (vHInt*vConst + vWDamCoeff*wDam*vWDamCoeffH + vWeight*vWInfH)*WSR_aggMastery*vSCoeffH
					if isDebug
						Print "DefY = " + $(vVInt*vConst) + " + " + $vSCoeffV + " + " + $(vWDamCoeff*wDam) + " - " + $(vWeight*vWInfV)
						;Print "vWeight=" + $vWeight
					endif
				endif
				
				

				if vRotationAsVertical == 0 
					let DefZ := DefX
				else
					let DefZ := DefY
				endif
				
				if vIsRand == 1
					let randn := getrandompercent
					if randn > 50
						let randn := 1
					else
						let randn := -1
					endif
				else
					let randn := 1
				endif
				
			
			endif
			
			let DefX *= randn
			
		endif
		
		; PrintToConsole "DefX 0 is: %g" DefX
		; PrintToConsole "DefY 0 is: %g" DefY
		; PrintToConsole "DefZ 0 is: %g" DefZ
		
		let vFirstShotV := 1
		let vFirstShotH := 1
		
		if VisuaModellRecoilQuest.IS_Tick == 0
		
			let DefTrans1 := Call vFirstShot vFirstShotMV, vFirstShotMH, vFirstShotR, vFirstShotP
			let vFirstShotH := DefTrans1[0]
			let vFirstShotV := DefTrans1[1]
		else
			if isDebug
				Print "You're too fast, honey!"
			endif
		endif
		
		let DefX *= vFirstShotH
		let DefY *= vFirstShotV
		
		if vRotationAsVertical == 0 
			let DefZ *= vFirstShotH
		else 
			let DefZ *= vFirstShotV
		endif
		
		let VisuaModellRecoilQuest.IS_Tick := vFirstShotP
		
		
		
		;this is where we try to take B42 Inertia into account
		; after all the updates this seems to be unnecessary, but JUST IN CASE IT WILL BE NOT
		if HasInertia == 1
			if (FileExists "Config\B42Inertia.ini") && (GetINIFloat "Tuning:bRotationMode" "B42Inertia.ini") > 0
				let fixMult := 0.9
				let fixMultIS := 0.95
				;let DefZ := DefZ*0.2
			elseif (GetINIFloat "Tuning:bDebugMode" "B42Inertia.ini") == 0 ;this was only for debugging, I got tired of switching plugins off, sorry
				let fixMult := 0.9
				let fixMultIS := 0.95
				;PrintToConsole "fixMultIS is: %g" fixMultIS
			else
				let fixMult := 0.9
				let fixMultIS := 0.95
				;let DefZ := DefZ*-1
			endif
		else
			let fixMult := 0.9
			let fixMultIS := 0.95
			;PrintToConsole "fixMultIS is: %g" fixMultIS
			;let DefZ := DefZ*-1
		endif
		
		
		
		if DefY > vVupLim 
			let DefY := vVupLim
		elseif DefY < vVlowLim
			let DefY := vVlowLim
		endif
		
		if (abs DefX) > vHupLim 
			let DefX := vHupLim*randn
		elseif (abs DefX) < vHlowLim*randn
			let DefX := vHlowLim*randn
		endif
		
		
		if isDebug
			Print "DefX Lim=" + $DefX + ", randn=" + $randn
		endif
		
		if vRotationAsVertical == 0 
			if (abs DefZ) > vHupLim 
				let DefZ := vHupLim*randn
			elseif (abs DefZ) < vHlowLim*randn
				let DefZ := vHlowLim*randn
			endif
		else
			if DefZ > vVupLim 
				let DefZ := vVupLim
			elseif DefZ < vVlowLim
				let DefZ := vVlowLim
			endif
		endif
		

		if (GetVATSMode <= 0) || IsVats == 0 ;an attempt to fix VATS-related bug, couldn't reproduce it though
			let VisuaModellRecoilQuest.MinCount := fixMult
			let VisuaModellRecoilQuest.MinCountI := fixMultIS
			
			let VisuaModellRecoilQuest.DefA0 := VisuaModellRecoilQuest.DefA0 + DefX;*fixMult
			let VisuaModellRecoilQuest.DefA1 := VisuaModellRecoilQuest.DefA1 + DefY;*fixMult
			
			let VisuaModellRecoilQuest.DefA2 := VisuaModellRecoilQuest.DefA2 + DefZ;*randn;*fixMult

			let VisuaModellRecoilQuest.timer := 0
		endif
		
		; let vSelf := GetCurrentScript
		
		; SetVariable "DefX", DefX, vSelf
		; SetVariable "DefY", DefY, vSelf
		
		if isDebug 
			let timer -= GetSecondsPassed
			
			Print "DefX is: " + $DefX
			Print "DefY is: " + $DefY
			Print "DefZ is: " + $DefZ
			Print "VMx is: " + $VisuaModellRecoilQuest.VMx
			Print "VMy is: " + $VisuaModellRecoilQuest.VMy
			Print "VMz is: " + $VisuaModellRecoilQuest.VMz + " in "+$timer + "s"
			
		
		endif

	endif	
end